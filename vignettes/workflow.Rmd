---
title: "Workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{rater workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>"
)
```

## What is rater?

The **rater** package is designed to allow easy fitting and analysis of
Bayesian models of categorical data annotation using
[Stan](http://mc-stan.org/). Here we demonstrate the basic workflow for using
the package.

## Data

We will use the *anesthesia* data set taken from the paper *Maximum Likelihood
Estimation of Observer Error-Rates Using the EM Algorithm* by A. P. Dawid and
A. M. Skene, the paper which introduced the type of models used in this
package. This dataset is already in the appropriate format for use by the
**rater()** function. For information about how to convert your data into the
appropriate format see __link__.

## mcmc()

The core function of the **rater** package is the `mcmc()` function which fits a model 
given data. This function has two arguments: `data`, which should be in 
'long' format (add footnote); and `model`, which specifies the model you would like to fit. 
Models are passed as a function (the reason for this will be more obvious in a moment). For 
example, to fit the basic Dawid and Skene model to the anesthesia dataset we 
would run: 

```{r}
# load the rater package
library(rater)

# load the anesthesia dataset
data("anesthesia")

# fit the model using MCMC via Stan 
fit <- mcmc(anesthesia, dawid_skene(), iter = 500, chains = 1)
```

You will see the normal progress output you get whenever **Stan** is sampling.
Note that all models are compiled when the package is installed, rather than at
runtime, meaning that you will not need to wait for a model to be compiled when
running analyses using the **rater** package.

Important note: in the example above we specified **Stan** to only run 1 chain
with 500 iterations in order to speed up the creation of this vignette and
reduce the volume of output. In general, we recommend running `mcmc()` using
the **Stan** sampling defaults, which will be used if you only specify the
`data` and `model` arguments in `mcmc()`.  For example:

```{r, eval = FALSE}
fit <- mcmc(anesthesia, dawid_skene())
```

## plot()

Having fit the Dawid and Skene model to the data we can now plot and extract key 
parameter estimates from the model. 

To plot the population prevalence estimates (the parameter $\pi$ in the model) we run:

```{r, fig.width=6, fig.height=4}
plot(fit, type = "prevalance") # or plot(fit, "pi")
```

To plot the probability confusion matrices of the raters (the parameter $\theta$ in the model) we run:

```{r, fig.width=6, fig.height=4}
plot(fit, type = "raters") # or plot(fit, "theta")
```

To plot the latent class estimates (the parameter $z$ in the model) we run:

```{r, fig.width=6, fig.height=8}
plot(fit, type = "latent_class") # or plot(fit, "z")
```

For a discussion of what these parameters in the model represent, please see the vignette __models__.

## extract()

Similarly, we can extract all of the estimates used to make these plots for further 
processing with the `extract` function:

```{r, eval = FALSE}
extract(fit, "prevalance") # or extract(fit, "pi")

extract(fit, "raters") # or extract(fit, "theta")

extract(fit, "latent_class") # or extract(fit, "z")
```

