---
title: "Data Format"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The **rater** package implements models of annotation which are flexible enough
to allow each incomplete designs. That is every rater may rate each object any number 
of times, including 0. This is a great advantage as it allows all types of real world
data to be used with the package however it does lead to some difficulty in representing 
the data a simple structure. 

The format which the **rater** package uses is the *long* or database style format.
In this format all the data is compressed into a series of columns with each row 
representing one instance of annotation or rating. 

To illustrate this lets look at the `anesthesia` dataset included in the package. 

```{r}
library(rater)
data("anesthesia")

s_anesthesia <- head(anesthesia)

knitr::kable(s_anesthesia)
```

Here we see there are three columns. These are:

1. `ii`, item index - which item is being rated
2. `jj`, rater (annotator) index - which rater is doing the rating
3. `y`, what rating was given

The last row of the above data should be read as: 'when the fourth rater rated
the first item they rated it as one'

This data format can easily include missing combinations of rater/item - we simply
don't include a row and can also include repeated measurements - the first three
rows of the above show rater 1 rating item 1 3 times. 

## Multinomial model

The only complication to this is the input to the multinomial model. Because this 
model completely pools across raters (i.e. ignores the effect of raters) there is 
need to tell the model which rater rated each item. Data input to the model should 
have 2 columns 

1. Item index 
2. Rating

i.e should look like:

```{r}
s_anesthesia_multi <- s_anesthesia[, c(1, 3)]

knitr::kable(s_anesthesia_multi)
```

As data of this form could be stored in many formats it is hard to automate 
the conversion of data to the format described here. It is therefore the package 
users' reponsibility to ensure correctly formatted data is passed into the models.
